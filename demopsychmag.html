<!DOCTYPE html>
<html>
  <head>
    <title>Magnitude pilot experiment</title>
    <script src="https://unpkg.com/jspsych@7.3.4" type="text/javascript"></script>
    <script src="https://unpkg.com/@jspsych/plugin-external-html"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload"></script>
    <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <link href="https://unpkg.com/jspsych/css/jspsych.css" rel="stylesheet" type="text/css">
    <script src="canvasMorpher.js"></script>


    <link href="https://unpkg.com/jspsych/css/jspsych@7.3.4.css" rel="stylesheet" type="text/css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .jspsych-btn { padding: 1px 20px;
      font-size: 20px;
      border-color: black;
      }
    </style>

  </head>
  <body></body>

  <script>

  // Training I, II: promoted noise range to [-1.5, 1.5] diff = 1.5
  // Test_equally : promoted noise range from [-1, 1] to [-2.5, 2.5] diff = 0
  // Testing : promoted noise range to [-2, 2] diff = 2

  /* initialize jsPsych */
  var jsPsych = initJsPsych({
    show_progress_bar: true,
  });

  var preload = {
      type: jsPsychPreload,
      show_progress_bar: true,
      images: ["img/05_low.png", "img/25a_low.png","img/25b_low.png","img/3a_low.png","img/3b_low.png",
               "img/35a_low.png","img/35b_low.png","img/4a_low.png","img/4b_low.png","img/5_low.png",
               "img/05_high.png","img/25a_high.png","img/25b_high.png","img/3a_high.png","img/3b_high.png",
               "img/35a_high.png","img/35b_high.png","img/4a_high.png","img/4b_high.png","img/5_high.png",
              ]
    };

  var getUrlParameter = function getUrlParameter(sParam) {
    var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'),
        sParameterName,
        i;

    for (i = 0; i < sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split('=');

        if (sParameterName[0] === sParam) {
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    }
  };

  var SONAID = getUrlParameter('id');
  var subjectID = SONAID;
  if (subjectID===undefined) {subjectID = this.jsPsych.randomization.randomID(8)}; //if ID isn't read in, best to give it a random value
  jsPsych.data.addProperties({subject_id: subjectID}); //this is the awkward way you need to call jspsych routines now!
  var check_consent = function(elem) {
    if (document.getElementById('consent_checkbox').checked) {
      return true;
    }
    else {
      alert("Please check the box next to the statement 'I agree to participate in this study.' if you wish to continue.");
      return false;
    }
    return false;
  };

  var consentTrial = {
    type:jsPsychExternalHtml,
    url: "https://lingsyrina.github.io/consent.html",
    cont_btn: "start",
    check_fn: check_consent
  };

    /* Instructions */
    /* welcome message */
    var welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p style="font-size:20px;font-weight:bold;"> Thank you for your participation! </p>
      <p>Press the space bar to begin.</p>
      `,
      choices: [' '], // restricts to space bar press
    };

    /* closing message */

     var waiting = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p> Thanks! Please press any key to save your responses. </br> It may take a few seconds -- please <strong>do not close the window </strong>until you see the confirmation page.</p>"
    };

    var closing = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p> Thank you very much again for your participation! We sincerely appreciate your time and effort.</p> <p>You can close your window whenever you feel comfortable.</p>"
    };

    var exp_break = {
      type: jsPsychHtmlButtonResponse,
      choices: ['<p style="font-size:14px;font-weight:bold;"> I am ready! </p>'],
      stimulus: `
        <p><strong>Perfect!</strong></p>
        <p>Maybe it's time for a short break! </br>Take your time, and click the button below whenever you feel ready to get back to our experiment.</br></br> </p>
      `,
      response_ends_trial: true,
      post_trial_gap: 500
    };

    /* instruction for learning phase_1 */
    // Passive learning
    var instruction_1 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> In this section, <br />
        You will <strong>compare pairs of images </strong> which appear in the center of the screen.<br />
        Below each image will be a statement that describes it. <br/></p>
        <p>All images are described as either <strong>orpital</strong> or <strong>frimble</strong>. <br/>
        For example, if an image is described as <strong>more orpital</strong>, then it is <strong>less frimble</strong>.<br/>
        Conversely, if an image is <strong>more frimble</strong>, then it is <strong>less orpital</strong>. </p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    // Active learning
    var instruction_2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> In this section, <br />
        you will continue to <strong>compare pairs of images</strong>. <br/>
        However, you will now be asked to <strong>choose the correct description</strong> for the <strong>image on the right</strong>.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      /* I am deliberately not telling them that they will be given limitless chances until they get it right -- just so they can pay more attention.*/
      post_trial_gap: 500
    };

    /* instruction for testing phase_1 */
    var instruction_3 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong> </p>
        <p> Continue answering our questions by <strong>selecting the correct description</strong> for the <strong>image on the right</strong>.</br> However, we are no longer telling you whether you\'ve got the right answer or not!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    /* instruction for learning phase_2 */
    //Passive
    var instruction_4 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> Welcome back!</p>
        <p> You will continue to see pairs of images accompanied by the description.
        <br/> This time, we are giving you more detailed description, using <strong>our own mysterious scale</strong>... </p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    var instruction_4_1 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong></p>
        <p> That was hard, right?
        <br/> Let's practice again. We will be giving you pairs of images <strong>with description</strong>... </p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };


    //Active
    var instruction_5 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Awesome!</strong> <br/>
        Now, we would like to ask you to <strong>guess the correct degree</strong> for each pair of images.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    var instruction_5_1 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Awesome!</strong> <br/>
        Now, let's try again and <strong>guess the correct degree</strong> for each pair of images.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    var instruction_5_2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great job!</strong> <br/>
        Let's try once again. Guess the correct degree for each pair of images!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    var instruction_5_2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Awesome!</strong> <br/>
        Now, we would like to ask you to <strong>guess the correct degree</strong> for each pair of images.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };


    /* instruction for testing phase_2a */
    var instruction_6 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong> </p>
        <p> Now we're going to give you a different set of questions. </br> Find the identical image!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    /* instruction for testing phase_2b */
    var instruction_7 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Excellent!</strong> </p>
        <p> You will continue to <strong>compare pairs of images</strong> and <strong>choose the correct description</strong> for the <strong>image on the right</strong>!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    /* instruction for testing phase_2b */
    var instruction_8 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great job!</strong> </p>
        <p> This is the last part of the experiment.<br/> This time you will be seeing <strong>different descriptions with familiar concepts </strong>. Choose the best one!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

      /* instruction for testing phase_2b */
    var instruction_xab = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p>Awesome!</p>
        <p>Now we are giving you a task similar to what you did at the beginning of the experiment. </br>Your task is to find <strong>the same image</strong> shown at the top of the screen.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    //Instruction for similarity test
    var instruction_sim = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong> </p>
        <p> We're going to give you another set of questions. </br> Now find the similar image!</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };

    var instruction_equally = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Awesome!</strong> <br/>
        Now, we would like to ask you to choose the <strong>correct statement for the image on the right</strong>.</p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
      post_trial_gap: 500
    };



     /* Fixation */
    var fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div style="font-size:60px;">+</div>`,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: {
        task: `fixation`
      }
    };
    var instruction_break = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p style="font-size:20px;font-weight:bold;"> Look at this pair! </p>
        <p>(Press the space bar to continue.)</p>
      `,
      choices: [' '], // restricts to space bar press
    };


    // frimble vs. orpital
    var choices = ['frimble', 'orpital']

    // word assignment
    if (Math.random() < 0.5) {
        var A = choices[0];
        var B = choices[1];
    } else {
        var A = choices[1];
        var B = choices[0];
    }


    // /* Function for generating canvas stimuli */
    // function Morphfunction(canvas, p1, p2){
    //     const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
    //     canvasMorpher.combineImages(canvas, p1, p2);
    // }


    /* Function for generating canvas stimuli */
  function Morphfunction(canvas, p1, p2, n1=0, n2=0) {
      return new Promise((resolve) => {
        const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
        canvasMorpher.combineImages(canvas, p1, p2, n1, n2, () => {
          resolve();
        });
      });
    }

    /* Function for generating canvas stimuli */
  function XAB_test(canvas, p1, p2, n1=0, n2=0, condition) {
      return new Promise((resolve) => {
        const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
        //console.log('noise', p1, p2, n1, n2, condition);
        canvasMorpher.XAB(canvas, p1, p2, n1, n2, condition, () => {
          resolve();
        });
      });
    }


   // random generator -- currently revised so that it spits 2 decimal places
   function getRandomArbitrary(min, max) {
        let nn = Math.random() * (max - min) + min;
        return Math.round(nn*100)/100;
   }

  // Initialize the random generator with a fixed seen
   Math.seedrandom('fixed-seed');

    /* Function for Learn stimuli (less restriction)*/
   function generateLearnStimuli(numStimuli, promptType = 1) { // 1=passive, 2=active
      const stimuli = [];
      const differences = [];
      for (let i = 5; i <= 9; i++) {
        differences.push(0.05 * i);
      }

      for (let i = 0; i < numStimuli; i++) {
        let p1, p2;
        const diff = differences[Math.floor(Math.random() * differences.length)];

        //let n1, n2;
        //const n = getRandomArbitrary(-.5, .5);

        if (i < numStimuli / 2) {
          p1 = getRandomArbitrary(0.15, 1 - diff);
          p2 = p1 + diff;
          //n1 = n;
          //n2 = (n1 +  1.5);
        } else {
          p2 = getRandomArbitrary(0.15, 1 - diff);
          p1 = p2 + diff;
          //n1 = n;
          //n2 = (n1 -  1.5);
        }

        const n1 = getRandomArbitrary(-1, 1);
        //const n2 = getRandomArbitrary(-1, 1);
        let n2;
        if (n1 < 0) {
            n2 = (n1 + 1.5);
        } else {
            n2 = (n1 - 1.5);
        }

        let prompt;
        if (promptType === 1) {
            if (p1 > p2){
                prompt = `<p style="font-size:20px;"> Compared to the left one, <strong>the right one is more ${A}</strong>.</p> <br /> (Press any key to continue to the next image)`;

            } else{
                prompt = `<p style="font-size:20px;"> Compared to the left one, <strong>the right one is more ${B}</strong>.</p> <br /> (Press any key to continue to the next image)`;
            }
        } else {
          prompt = `<p>Compared to the left, <strong>the right image is</strong>...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`;
        }

        stimuli.push({
          stimulus: (i + 1).toString(),
          task: 'block1_passive_response',
          radius_a: p1,
          radius_b: p2,
          n1: n1,
          n2: n2,
          prompt: prompt,
          correct_response: p1 > p2 ? 'q' : 'p'});
      }

      return stimuli;
    }

    /*test stimuli; more restricted */

   function generateTestStimuli(numStimuli) {
        const stimuli = [];
        const differences = [0.05 * 2, 0.05 * 9, 0.05 * 13, 0.05 * 16]; //0.05 * d where d = |p1-p2|
        const numDiff = differences.length;
        

        //determine # of stimuli for each distance
        const baseC = Math.floor(numStimuli / numDiff);
        const extraC = numStimuli % numDiff;

        //array with the distribution of counts
        const counts = new Array(numDiff).fill(baseC);
        for (let i = 0; i < extraC; i++){
            counts[i]++;
        }

        for (let j = 0; j < numStimuli; j++) {
                let p1, p2;
                const diff = differences[Math.floor(Math.random() * differences.length)];

                    // Create half of the stimuli with p1 < p2 and the other half with p1 > p2
                    if (stimuli.length < numStimuli / 2) {
                        // p1 < p2
                        p1 = getRandomArbitrary(0.0, 1 - diff);
                        p2 = p1 + diff;
                    } else {
                        // p1 > p2
                        p2 = getRandomArbitrary(0.0, 1 - diff);
                        p1 = p2 + diff;
                    }

                    // Generate n1 and n2 values
                    const n1 = getRandomArbitrary(-1.5, 1.5);
                    let n2;
                    if (n1 < 0) {
                        n2 = (n1 + 2);
                    } else {
                        n2 = (n1 - 2);
                    }

                    // Add stimulus to the array
                    stimuli.push({
                        stimulus: (stimuli.length + 1).toString(),
                        radius_a: p1,
                        radius_b: p2,
                        n1: n1,
                        n2: n2,
                        correct_response: p1 > p2 ? 'q' : 'p'
                    });
                
            }

            // Shuffle the stimuli array to randomize the order
            for (let i = stimuli.length - 1; i > 0; i--){
                const j = Math.floor(Math.random() * (i + 1));
                [stimuli[i], stimuli[j]] = [stimuli[j], stimuli[i]]
            }

            return stimuli;
      }

   function generateEqualTestStimuli(numStimuli) {
        const stimuli = [];
        const differences = [0.05 * 0, 0.05 * 1, 0.05 * 2, 0.05 * 3, 0.05 * 4]; //0.05 * d where d = |p1-p2|

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.05, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.05, 1 - diff);
            p1 = p2 + diff;
          }

          const n1 = getRandomArbitrary(-2.5, 2.5); // promoted range from [-1, 1] to [-2.5, 2.5]
          //const n2 = getRandomArbitrary(-1, 1);
          let n2;
          if (n1 < 0) {
              n2 = n1 - 0;
          } else {
              n2 = n1 + 0;
          }

          stimuli.push({
            stimulus: (i + 1).toString(),
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            prompt: `<p style="font-size:20px;">Compared to the left one, <strong>the right one is...</strong><br /> <strong>1</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>2</strong>: more <strong>${B}</strong>. &emsp;&emsp; <strong>3</strong>: equally <strong>${A}</strong>.&emsp;&emsp; <strong>4</strong>: equally <strong>${B}</strong>. </p>`,
          });
        }

        return stimuli;
      }

   function passiveDegreeStimuli(numStimuli, n) {
        const stimuli = [];
        const differences = [];
        for (let i = 5; i <= 9; i++) {
          differences.push(0.05 * i);
        }

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.15, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.15, 1 - diff);
            p1 = p2 + diff;
          }

          //const n1 = getRandomArbitrary(-2.5, 2.5); // promoted range from [-1, 1] to [-2.5, 2.5]
          //const n2 = getRandomArbitrary(-2.5, 2.5); // promoted range from [-1, 1] to [-2.5, 2.5]
          const n1 = getRandomArbitrary(-1, 1);
          //const n2 = getRandomArbitrary(-1, 1);
          let n2;
          if (n1 < 0) {
              n2 = (n1 + 1.5);
          } else {
              n2 = (n1 - 1.5);
          }


          const degreeDifference = Math.trunc(diff / n);
          let prompt;
          if (p1 > p2) {
              prompt = `<p style="font-size:20px;">Compared to the left one, <strong>the right one is ${degreeDifference} degree(s) more ${A}</strong>.</p><br />(Press any key to continue to the next image)`;
          } else {
              prompt = `<p style="font-size:20px;">Compared to the left one, <strong>the right one is ${degreeDifference} degree(s) more ${B}</strong>.</p><br />(Press any key to continue to the next image)`;
          }

          stimuli.push({
            stimulus: (i + 1).toString(),
            task: 'block2_passive_response',
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            prompt: prompt,
            correct_response: p1 > p2 ? 'q' : 'p'
          });
        }

        return stimuli;
      }

   function activeDegreeStimuli(numStimuli, n) {
        const stimuli = [];
        const differences = [];
        for (let i = 5; i <= 9; i++) {
          differences.push(0.05 * i);
        }

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.15, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.15, 1 - diff);
            p1 = p2 + diff;
          }

          //const n1 = getRandomArbitrary(-2.5, 2.5); // promoted range from [-1, 1] to [-2.5, 2.5]
          //const n2 = getRandomArbitrary(-2.5, 2.5); // promoted range from [-1, 1] to [-2.5, 2.5]
          const n1 = getRandomArbitrary(-1, 1);
          let n2;
          if (n1 < 0) {
              n2 = (n1 + 1.5);
          } else {
              n2 = (n1 - 1.5);
          }

          const degreeDifference = Math.trunc(diff / n);
          let prompt;
          if (p1 > p2) {
              prompt = `<p style="font-size:20px;"><strong>From 1 to 4</strong>, how many degree(s) is <strong>the right one more ${A}</strong>?</br>(Use number keys)</p>`;
          } else {
              prompt = `<p style="font-size:20px;"><strong>From 1 to 4</strong>, how many degree(s) is <strong>the right one more ${B}</strong>?</br>(Use number keys)</p>`;
          }

          stimuli.push({
            stimulus: (i + 1).toString(),
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            prompt: prompt,
            correct_response: degreeDifference
          });
        }

        return stimuli;
      }
      /* Specific stimuli for pre_test_xab */
      // condition == 1 then p1 is shown as main stimulus, else p2
      var pre_test_stimuli = [
        { p1: 0.05, p2: 0.2, n1: 0, n2: 0, condition: 1},   //1-4
        { p1: 0.15, p2: 0.3, n1: 0, n2: 0, condition: 0},                 //3-5, newly added (July 18th)
        { p1: 0.25, p2: 0.4, n1: 0, n2: 0, condition: 1},    //5-8
        { p1: 0.35, p2: 0.5, n1: 0, n2: 0, condition: 0},                 //7-10, newly added
        { p1: 0.45, p2: 0.6, n1: 0, n2: 0, condition: 1},   //9-12
        { p1: 0.55, p2: 0.7, n1: 0, n2: 0, condition: 0},                 //11-14, newly added
        { p1: 0.65, p2: 0.8, n1: 0, n2: 0, condition: 1},   //13-16
        { p1: 0.85, p2: 1.0, n1: 0, n2: 0, condition: 0},                 //17-20
        { p1: 0.05, p2: 0.05, n1: 0, n2: 0.15*670/70, condition: 0},
        { p1: 0.15, p2: 0.15, n1: 0, n2: 0.15*670/70, condition: 1},  //newly added
        { p1: 0.25, p2: 0.25, n1: 0, n2: 0.15*670/70, condition: 0},
        { p1: 0.35, p2: 0.35, n1: 0, n2: 0.15*670/70, condition: 1},     //newly added
        { p1: 0.45, p2: 0.45, n1: 0, n2: 0.15*670/70, condition: 0},
        { p1: 0.55, p2: 0.55, n1: 0, n2: 0.15*670/70, condition: 1},     //newly added
        { p1: 0.65, p2: 0.65, n1: 0, n2: 0.15*670/70, condition: 0},
        { p1: 0.85, p2: 0.85, n1: 0, n2: 0.15*670/70, condition: 1}
      ];

    // 15 XAB similarity trials
      var delta = 0.15;
      var similarity_stimuli = [
        { p1: 0.00, p2: 0.00+delta, n1: delta*670/70, n2: 0,  condition: 1},
        { p1: 0.05, p2: 0.05+delta, n1: 0, n2: delta*670/70,  condition: 2},
        { p1: 0.15, p2: 0.15+delta, n1: delta*670/70, n2: 0,  condition: 1},
        { p1: 0.25, p2: 0.25+delta, n1: 0, n2: delta*670/70,  condition: 2},
        { p1: 0.35, p2: 0.35+delta, n1: delta*670/70, n2: 0,  condition: 1},
        { p1: 0.45, p2: 0.45+delta, n1: 0, n2: delta*670/70,  condition: 2},
        { p1: 0.55, p2: 0.55+delta, n1: delta*670/70, n2: 0,  condition: 1},
        { p1: 0.65, p2: 0.65+delta, n1: 0, n2: delta*670/70,  condition: 2},
        { p1: 0.75, p2: 0.75+delta, n1: delta*670/70, n2: 0,  condition: 1},
        { p1: 0.85, p2: 0.85+delta, n1: 0, n2: delta*670/70,  condition: 2}
      ];


      /* Function to convert specific stimuli to timeline variables */
      function convertToTimelineVariables(stimuli) {
        return stimuli.map((stimulus, index) => ({
          stimulus: index.toString(),
          radius_a: stimulus.p1,
          radius_b: stimulus.p2,
          n1: stimulus.n1,
          n2: stimulus.n2,
          condition: stimulus.condition,
          correct_response: stimulus.condition == 1 ? 'q' : 'p',
        }));
      }

      /*Stimuli number*/
      var active = 35;
      var active_d = 15;    //# trials for degree training
      var active_d2 = 15;
      var active_d3 = 15;
      var passive = 15;
      var passive_d = 7;   //# trials for degree training
      var passive_d2 = 8;
      var test = 32;
      var equally = 30;
      var highp = 0.05 * 2;
      var lowp = 0.05 * 4;

      //For debug only (should be commented out for real experiment)    
      var active = 1;
      var active_d = 1;
      var active_d2 = 1;
      var active_d3 = 1;
      var passive = 1;
      var passive_d = 1;
      var passive_d2 = 1;
      var test = 1;
      var equally = 1;
      var highp = 0.05 * 2;
      var lowp = 0.05 * 4;
      var pre_test_stimuli = [
        { p1: 0.05, p2: 0.2, n1: 0, n2: 0,  condition: 1},
      ];
      
      /*pretest*/
      var pre_test_xab_stimuli = convertToTimelineVariables(pre_test_stimuli);

      /* Stimuli for similarity XAB */
      var sim_xab_stimuli = convertToTimelineVariables(similarity_stimuli);

      /* Stimuli for learning_phase_1 */
      var learn_stimuli_a1 = generateLearnStimuli(passive, 1); // (15 trial, 1: passive)

      /* Stimuli for learning_phase_2 */
      var learn_stimuli_a2 = generateLearnStimuli(active, 2); // (35 trial, 2: active)

      /* Stimuli for learning_phase_1C */
      // Should we adjust low precision so that it's always non-zero? (Validating equally tests)
      var learn_stimuli_c1h = passiveDegreeStimuli(passive_d,highp); // 15 passive learning, high precision (0.2)
      var learn_stimuli_c2h = activeDegreeStimuli(active_d,highp); // 35 active larning, high precision
      var learn_stimuli_c3h = passiveDegreeStimuli(passive_d2,highp); // 15 passive learning, high precision (0.2)
      var learn_stimuli_c4h = activeDegreeStimuli(active_d2,highp); // 35 active larning, high precision
      var learn_stimuli_c5h = activeDegreeStimuli(active_d3,highp); // 35 active larning, high precision


      var learn_stimuli_c1l = passiveDegreeStimuli(passive_d,lowp); // 15 passive learning, low precision (0.4)
      var learn_stimuli_c2l = activeDegreeStimuli(active_d,lowp); // 35 passive learning, low precision (0.4)
      var learn_stimuli_c3l = passiveDegreeStimuli(passive_d2,lowp); // 15 passive learning, low precision (0.4)
      var learn_stimuli_c4l = activeDegreeStimuli(active_d2,lowp); // 35 passive learning, low precision (0.4)
      var learn_stimuli_c5l = activeDegreeStimuli(active_d3,lowp); // 35 passive learning, low precision (0.4)


      /* Stimuli for testing 'more A/B' */
    //after XAB test (identical to the pre_XAB_test)
      var test_stimuli = generateTestStimuli(test); // 27 random parameters
      // Array of test stimuli without correct_response
      var new_stimuli = [
        { radius_a: 0, radius_b: 0.25, n1: 0, n2: 0 },
        { radius_a: 0.25, radius_b: 0, n1: 0, n2: 0 },
        { radius_a: 0.05, radius_b: 0.30, n1: 0, n2: 0 },
        { radius_a: 0.30, radius_b: 0.05, n1: 0, n2: 0 },
        { radius_a: 0.75, radius_b: 1, n1: 0, n2: 0 },
        { radius_a: 1, radius_b: 0.75, n1: 0, n2: 0 },
        { radius_a: 0.70, radius_b: 0.95, n1: 0, n2: 0 },
        { radius_a: 0.95, radius_b: 0.70, n1: 0, n2: 0 }
      ];
      
      // Add correct_response dynamically based on p1 > p2
      new_stimuli.forEach(stimuli => {
        stimuli.correct_response = stimuli.p1 > stimuli.p2 ? 'q' : 'p';
      });
      
      // Push the new stimuli to test_stimuli array
      test_stimuli.push(...new_stimuli);
      
      console.log(test_stimuli);

      /* Stimuli for testing equally */
      //after XAB test (identical to the pre_XAB_test)
    var test_stimuli_equally = generateEqualTestStimuli(equally); // 30 random parameters

    /* Stimuli for language survey */
    var test_stimuli_s = [
      { stimulus: 'img/05_low.png', word: "tall", antonym: "short", condition: '05_low'},
      { stimulus: 'img/25a_low.png', word: "tall", antonym: "short", condition: '25a_low'},
      { stimulus: 'img/25b_low.png', word: "tall", antonym: "short", condition: '25b_low'},
      { stimulus: 'img/3a_low.png', word: "tall", antonym: "short", condition: '3a_low'},
      { stimulus: 'img/3b_low.png', word: "tall", antonym: "short", condition: '3b_low'},
       { stimulus: 'img/35a_low.png', word: "tall", antonym: "short", condition: '35a_low'},
      { stimulus: 'img/35b_low.png', word: "tall", antonym: "short", condition: '35b_low'},
      { stimulus: 'img/4a_low.png', word: "tall", antonym: "short", condition: '4a_low'},
      { stimulus: 'img/4b_low.png', word: "tall", antonym: "short", condition: '4b_low'},
      { stimulus: 'img/5_low.png', word: "tall", antonym: "short", condition: '5_low'},
      { stimulus: 'img/05_high.png', word: "tall", antonym: "short", condition: '05_high'},
      { stimulus: 'img/25a_high.png', word: "tall", antonym: "short", condition: '25a_high'},
      { stimulus: 'img/25b_high.png', word: "tall", antonym: "short", condition: '25b_high'},
      { stimulus: 'img/3a_high.png', word: "tall", antonym: "short", condition: '3a_high'},
      { stimulus: 'img/3b_high.png', word: "tall", antonym: "short", condition: '3b_high'},
      { stimulus: 'img/35a_high.png', word: "tall", antonym: "short", condition: '35a_high'},
      { stimulus: 'img/35b_high.png', word: "tall", antonym: "short", condition: '35b_high'},
      { stimulus: 'img/4a_high.png', word: "tall", antonym: "short", condition: '4a_high'},
      { stimulus: 'img/4b_high.png', word: "tall", antonym: "short", condition: '4b_high'},
      { stimulus: 'img/5_high.png', word: "tall", antonym: "short", condition: '5_high'},
      ];


/* Experiment procedures */

      var pre_test = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_pre_test`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 n1: jsPsych.timelineVariable(`n1`),
                 n2: jsPsych.timelineVariable(`n2`),
                 condition: (jsPsych.timelineVariable('condition')),
             },
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
       };

      var XABtest = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_test`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 n1: jsPsych.timelineVariable(`n1`),
                 n2: jsPsych.timelineVariable(`n2`),
                 condition: (jsPsych.timelineVariable('condition')),
             },
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
       };

      var XABtest2 = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_test2`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 n1: jsPsych.timelineVariable(`n1`),
                 n2: jsPsych.timelineVariable(`n2`),
                 condition: (jsPsych.timelineVariable('condition')),
             },
          on_finish: function(data) {
            // Score the response as correct or incorrect.
            if (data.response != data.correct_response) {
              data.correct = false;
            } else {
              data.correct = true;
            }
          }
       };

    // Similarity XABs
    var pre_test_sim = {
       type: jsPsychCanvasKeyboardResponse,
       canvas_size: [600, 600],
       stimulus: async function(c) {
         const stim = jsPsych.timelineVariable();
         await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
         return c;
       },
       choices: ['q', 'p'],
       prompt: "<p>Which image is more similar to the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
       response_ends_trial: true,
       data: {
               task: `XAB_pre_test_sim`,
               correct_response: jsPsych.timelineVariable(`correct_response`),
               stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
               stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
               n1: jsPsych.timelineVariable(`n1`),
               n2: jsPsych.timelineVariable(`n2`),
               condition: (jsPsych.timelineVariable('condition')),
           },
      on_finish: function(data) {
        // Score the response as correct or incorrect.
        if (data.response != data.correct_response) {
          data.correct = false;
        } else {
          data.correct = true;
        }
      }
     };

    var XABtest_sim = {
       type: jsPsychCanvasKeyboardResponse,
       canvas_size: [600, 600],
       stimulus: async function(c) {
         const stim = jsPsych.timelineVariable();
         await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
         return c;
       },
       choices: ['q', 'p'],
       prompt: "<p>Which image is more similar to the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
       response_ends_trial: true,
       data: {
               task: `XAB_test_sim`,
               correct_response: jsPsych.timelineVariable(`correct_response`),
               stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
               stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
               condition: (jsPsych.timelineVariable('condition')),
           },
      on_finish: function(data) {
        // Score the response as correct or incorrect.
        if (data.response != data.correct_response) {
          data.correct = false;
        } else {
          data.correct = true;
        }
      }
     };

    var XABtest_sim2 = {
       type: jsPsychCanvasKeyboardResponse,
       canvas_size: [600, 600],
       stimulus: async function(c) {
         const stim = jsPsych.timelineVariable();
         await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
         return c;
       },
       choices: ['q', 'p'],
       prompt: "<p>Which image is more similar to the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
       response_ends_trial: true,
       data: {
               task: `XAB_test_sim2`,
               correct_response: jsPsych.timelineVariable(`correct_response`),
               stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
               stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
               n1: jsPsych.timelineVariable(`n1`),
               n2: jsPsych.timelineVariable(`n2`),
               condition: (jsPsych.timelineVariable('condition')),
           },
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
     };


    /* block1: learning task */
    /* 1.1 learning: define learning trials*/
    var learn_A_passive = {
        type: jsPsychCanvasKeyboardResponse,
        canvas_size: [400, 900],
        stimulus: async function(c) {
          await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'),);
          return c;
        },
        prompt: jsPsych.timelineVariable(`prompt`),
        data: {
                task:jsPsych.timelineVariable('block1_passive_response'),
                stimuli_1: jsPsych.timelineVariable(`radius_a`),
                stimuli_2: jsPsych.timelineVariable(`radius_b`),
            },
      };

     var learn_A_active = {
        type: jsPsychCanvasKeyboardResponse,
        canvas_size: [400, 900],
        stimulus: async function(c) {
          await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
          return c;
        },
        response_ends_trial: true,
        data: {
                task: `block1_active_response`,
                stimuli_1: jsPsych.timelineVariable(`radius_a`),
                stimuli_2: jsPsych.timelineVariable(`radius_b`),
                n1: jsPsych.timelineVariable(`n1`),
                n2: jsPsych.timelineVariable(`n2`),
                correct_response: jsPsych.timelineVariable(`correct_response`)
            },
        choices: ['q', 'p'],
        prompt: jsPsych.timelineVariable(`prompt`),
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
      };

      // Feedback trial
      var feedback = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
          return last_trial_correct ? "<p style=font-size:20px;font-weight:bold;>Yes! Great job!</p>" : "<p style=font-size:20px;font-weight:bold;>Nope, let's try again!</p>";
        },
        choices: 'NO_KEYS',
        trial_duration: 700 // .7 second
      };

      // Loop which includes feedback trial
      var looped_A_active = {
        timeline: [learn_A_active, feedback],
        loop_function: function(data) {
          return !data.values()[0].correct; // Continue looping if the response was incorrect
        }
      };

      var test = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [400, 900],
         stimulus: async function(c) {
           await Morphfunction(c, jsPsych.timelineVariable(`radius_a`), jsPsych.timelineVariable(`radius_b`),jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
           return c;
         },
         response_ends_trial: true,
         data: {
                 task: `test_response_predegree`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 n1: jsPsych.timelineVariable(`n1`),
                 n2: jsPsych.timelineVariable(`n2`)
             },

        choices: ['q', 'p'],
        prompt: `<p>Compared to the left, <strong>the right image is</strong>...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`,
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
       };

       var learn_C_active = {
          type: jsPsychCanvasKeyboardResponse,
          canvas_size: [400, 900],
          stimulus: async function(c) {
            await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'),jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
            return c;
          },
          prompt: jsPsych.timelineVariable(`prompt`),
          response_ends_trial: true,
          data: {
                  task: `block2_active_response`,
                  correct_response: jsPsych.timelineVariable(`correct_response`),
                  stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                  stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                  n1: jsPsych.timelineVariable(`n1`),
                  n2: jsPsych.timelineVariable(`n2`)
              },
        on_finish: function(data) {
          // Score the response as correct or incorrect.
          if (data.response != data.correct_response) {
            data.correct = false;
          } else {
            data.correct = true;
          }
        }
        };

        // Loop which includes feedback trial
        var looped_C_active = {
          timeline: [learn_C_active, feedback],
          loop_function: function(data) {
            return !data.values()[0].correct; // Continue looping if the response was incorrect
          }
        };

        var test2 = {
           type: jsPsychCanvasKeyboardResponse,
           canvas_size: [400, 900],
           stimulus: async function(c) {
             await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'),jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
             return c;
           },
           response_ends_trial: true,
           data: {
                   task: `test_response_postdegree`,
                   correct_response: jsPsych.timelineVariable(`correct_response`),
                   stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                   stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                   n1: jsPsych.timelineVariable(`n1`),
                   n2: jsPsych.timelineVariable(`n2`)
               },


          choices: ['q', 'p'],
          prompt: `<p>Compared to the left, <strong>the right image is</strong>...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`,
          on_finish: function(data) {
            // Score the response as correct or incorrect.
            if (data.response != data.correct_response) {
              data.correct = false;
            } else {
              data.correct = true;
            }
          }
         };

      var test_equally_1 = {
           type: jsPsychCanvasKeyboardResponse,
           canvas_size: [400, 900],
           stimulus: async function(c) {
             await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
             return c;
           },
           response_ends_trial: true,
           data: {
                   task: `test_equally_predegree`,
                   stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                   stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                   n1: jsPsych.timelineVariable(`n1`),
                   n2: jsPsych.timelineVariable(`n2`)
               },


          choices: ['1', '2', '3', '4'],
          prompt: jsPsych.timelineVariable(`prompt`),
          on_finish: function(data){
                       // Score the response as correct or incorrect.
                       if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                         data.correct = false;
                       } else {
                         data.correct = true;
                       }
           }
         };

         var test_equally_2 = {
            type: jsPsychCanvasKeyboardResponse,
            canvas_size: [400, 900],
            stimulus: async function(c) {
              await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'));
              return c;
            },
            response_ends_trial: true,
            data: {
                    task: `test_equally_postdegree`,
                    stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                    stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                    n1: jsPsych.timelineVariable(`n1`),
                    n2: jsPsych.timelineVariable(`n2`)
                },


           choices: ['1', '2', '3', '4'],
           prompt: jsPsych.timelineVariable(`prompt`),
           on_finish: function(data){
                        // Score the response as correct or incorrect.
                        if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                          data.correct = false;
                        } else {
                          data.correct = true;
                        }
            }
          };


         var real_adj = {
             type: jsPsychImageKeyboardResponse,
             stimulus: jsPsych.timelineVariable(`stimulus`),
             stimulus_height: 400,
             choices: ['1', '2', '3', '4'],
             prompt:function() {
               var word = jsPsych.timelineVariable('word');
               var antonym = jsPsych.timelineVariable('antonym');
               return `<p style="font-size:20px;">Compared to the left one, <strong>the right one is...</strong><br /> <strong>1</strong>: <strong>${word}er</strong>.&emsp;&emsp; <strong>2</strong>: <strong>${antonym}er</strong>. &emsp;&emsp; <strong>3</strong>: equally <strong>${word}</strong>.&emsp;&emsp; <strong>4</strong>: equally <strong>${antonym}</strong>. </p>`},
             response_ends_trial: true,
             data: {
                     task: `Language_survey`,
                     condition: (jsPsych.timelineVariable(`condition`)),
                 },
             on_finish: function(data){
                          // Score the response as correct or incorrect.
                          if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                            data.correct = false;
                          } else {
                            data.correct = true;
                          }
              }
         };


      // Reset the RNG to use the default random behavior for timeline randomization
      Math.seedrandom();

      /* define learning procedure*/
      var pre_test_xab = {
        timeline: [instruction_break, pre_test],
        timeline_variables:pre_test_xab_stimuli,
        randomize_order: true
      };
      var pre_test_xab_sim = {
        timeline: [instruction_break, pre_test_sim],
        timeline_variables:sim_xab_stimuli,
        randomize_order: true
      };
      // Block I: learning (passive + active)
      var learn_procedure_1 = {
        timeline: [instruction_break, learn_A_passive],
        timeline_variables:learn_stimuli_a1,
        randomize_order: true
      };
      var learn_procedure_2 = {
        timeline: [instruction_break,looped_A_active],
        timeline_variables: learn_stimuli_a2,
        randomize_order: true,
      };
      // Block II: testing
      var xab_test_1 = {
        timeline: [instruction_break, XABtest],
        timeline_variables:pre_test_xab_stimuli,
        randomize_order: true
      };
      var xab_test_1_sim = {
        timeline: [instruction_break, XABtest_sim],
        timeline_variables:sim_xab_stimuli,
        randomize_order: true
      };
      var test_procedure_1 = {
         timeline: [instruction_break, test],
         timeline_variables: test_stimuli,
         randomize_order: true,
       };

      var equally_test_1 = {
           timeline: [instruction_break, test_equally_1],
           timeline_variables: test_stimuli_equally,
           randomize_order: true,
         };

       // Block III: learning (passive + active)
       var learn_procedure_3h = {
         timeline: [instruction_break, learn_A_passive],
         timeline_variables:learn_stimuli_c1h,
         randomize_order: true,
       };

       var learn_procedure_4h = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c2h,
         randomize_order: true,
       };

      var learn_procedure_5h = {
         timeline: [instruction_break, learn_A_passive],
         timeline_variables:learn_stimuli_c3h,
         randomize_order: true,
       };

       var learn_procedure_6h = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c4h,
         randomize_order: true,
       };

      var learn_procedure_7h = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c5h,
         randomize_order: true,
       };

      var learn_procedure_3l = {
        timeline: [instruction_break, learn_A_passive],
        timeline_variables:learn_stimuli_c1l,
        randomize_order: true,
      };

      var learn_procedure_4l = {
        timeline: [instruction_break,looped_C_active],
        timeline_variables: learn_stimuli_c2l,
        randomize_order: true,
      };

      var learn_procedure_5l = {
         timeline: [instruction_break, learn_A_passive],
         timeline_variables:learn_stimuli_c3l,
         randomize_order: true,
       };

       var learn_procedure_6l = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c4l,
         randomize_order: true,
       };

      var learn_procedure_7l = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c5l,
         randomize_order: true,
       };

       // Block IV: testing
       var xab_test_2 = { // XAB TEST
          timeline: [instruction_break, XABtest2],
          timeline_variables: pre_test_xab_stimuli,
          randomize_order: true,
        };
      var xab_test_2_sim = {
          timeline: [instruction_break, XABtest_sim2],
          timeline_variables:sim_xab_stimuli,
          randomize_order: true
        };

      var test_procedure_2 = {
           timeline: [instruction_break, test2],
           timeline_variables: test_stimuli,
           randomize_order: true,
         };

      var equally_test_2 = {
           timeline: [instruction_break, test_equally_2],
           timeline_variables: test_stimuli_equally,
           randomize_order: true,
         };


     var survey = {
       timeline: [instruction_break, real_adj],
       timeline_variables: test_stimuli_s,
       randomize_order: true,
     }



    // save to OFS server (check documentation)
    //  var save_server_data = {
    //   type: jsPsychCallFunction,
    //   func: function () {
    //     var data = jsPsych.data.get().ignore("internal_node_id").json();//ommitting .filter({task: 'property'}) to include all trials
    //     var xhr = new XMLHttpRequest();
    //     xhr.open('POST', 'php/save_json.php');
    //     xhr.setRequestHeader('Content-Type', 'application/json');
    //     xhr.send(JSON.stringify({ filedata: data }));
    //     jsPsychPipe.save(experiment_id, filename, data)
    //   },
    //   post_trial_gap: 1000
    // }

    const expID = "iPtLEVGIdxPA";
    let condition;
    let group_name;

    const save_server_data = {
      type: jsPsychPipe,
      action: "save",
      experiment_id: expID,
      filename: () => `${group_name}_${subjectID}_${A}.csv`,
      data_string: ()=>jsPsych.data.get().csv(),
      post_trial_gap: 1000
    };

    async function getCondition() {
      try {
        const response = await jsPsychPipe.getCondition(expID);
        console.log('Response:', response); // Log the response to confirm

        // Check if the response is a valid condition number
        if (typeof response === 'number') {
          return response;
        } else {
          throw new Error('Invalid response format');
        }
      } catch (error) {
        console.error('Failed to get condition:', error);
      }
    }


    async function createExperiment() {
      condition = await getCondition();

      var timeline = [];
      timeline.push(preload);
      timeline.push(welcome, consentTrial);

      /*block1: XAB & Pretrain; Same across all groups*/
      timeline.push(pre_test_xab);
      // timeline.push(instruction_sim, pre_test_xab_sim);
      timeline.push(instruction_1, learn_procedure_1);
      timeline.push(instruction_2, learn_procedure_2);

      /*block2: test; Same across all groups*/
      timeline.push(instruction_xab, xab_test_1);
      // timeline.push(instruction_sim, xab_test_1_sim);
      timeline.push(instruction_3, test_procedure_1);
      timeline.push(instruction_equally, equally_test_1); //need modification

      timeline.push(exp_break);

      /*block3: train; Constrast between two groups*/
      if (condition === 0) { //high precision
        group_name = 'high';
        jsPsych.data.addProperties({ precision_group: 'high' });
        timeline.push(instruction_4, learn_procedure_3h);
        timeline.push(instruction_5, learn_procedure_4h);
        timeline.push(instruction_4_1, learn_procedure_5h);
        timeline.push(instruction_5_1, learn_procedure_6h);
        timeline.push(instruction_5_2, learn_procedure_7h);
      } else { // low precision
        group_name = 'low';
        jsPsych.data.addProperties({ precision_group: 'low' });
        timeline.push(instruction_4, learn_procedure_3l);
        timeline.push(instruction_5, learn_procedure_4l);
        timeline.push(instruction_4_1, learn_procedure_5l);
        timeline.push(instruction_5_1, learn_procedure_6l);
        timeline.push(instruction_5_2, learn_procedure_7l);
      }

      /*block4: test; Same across all groups*/
      timeline.push(instruction_6, xab_test_2);
      // timeline.push(instruction_sim, xab_test_2_sim);
      timeline.push(instruction_7, test_procedure_2);
      timeline.push(instruction_equally, equally_test_2);

      /*survey: Same across all groups*/
      //Follow-up trial with real adjectives
      timeline.push(instruction_8, survey); //need modification

      /*save_data*/
      timeline.push(waiting);
      timeline.push(save_server_data);
      timeline.push(closing);


      jsPsych.run(timeline)
    }

  createExperiment();


  </script>
</html>
