<!DOCTYPE html>
<html>
  <head>
    <title>Magnitude pilot experiment</title>
    <script src="https://unpkg.com/jspsych"></script>
    <script src="https://unpkg.com/@jspsych/plugin-external-html"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-button-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-button-response"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload"></script>
    <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <link href="https://unpkg.com/jspsych/css/jspsych.css" rel="stylesheet" type="text/css">
    <script src="canvasMorpher.js"></script>


    <link href="https://unpkg.com/jspsych/css/jspsych.css" rel="stylesheet" type="text/css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .jspsych-btn { padding: 1px 20px;
      font-size: 20px;
      border-color: black;
      }
    </style>

  </head>
  <body></body>

  <script>

      
  /* initialize jsPsych */
  var jsPsych = initJsPsych({
    show_progress_bar: true,
  });

  var getUrlParameter = function getUrlParameter(sParam) {
    var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'),
        sParameterName,
        i;

    for (i = 0; i < sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split('=');

        if (sParameterName[0] === sParam) {
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    }
  };

  var SONAID = getUrlParameter('id');
  var subjectID = SONAID;
  if (subjectID===undefined) {subjectID = this.jsPsych.randomization.randomID(8)}; //if ID isn't read in, best to give it a random value
  jsPsych.data.addProperties({subject_id: subjectID}); //this is the awkward way you need to call jspsych routines now!
  var check_consent = function(elem) {
    if (document.getElementById('consent_checkbox').checked) {
      return true;
    }
    else {
      alert("Please check the box next to the statement 'I agree to participate in this study.' if you wish to continue.");
      return false;
    }
    return false;
  };

  var consentTrial = {
    type:jsPsychExternalHtml,
    url: "https://lingsyrina.github.io/consent.html",
    cont_btn: "start",
    check_fn: check_consent
  };

    /* Instructions */
    /* welcome message */
    var welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p style="font-size:20px;font-weight:bold;"> Thank you for your participation! </p> <p> Press any key to begin.</p>`
    };

    /* closing message */

     var waiting = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p> Thanks! Please press any key to save your responses. </br> It may take a few seconds -- please <strong>do not close the window </strong>until you see the confirmation page.</p>"
    };
    
    var closing = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p> Thank you very much again for your participation! We sincerely appreciate your time and effort.</p> <p>You can close your window whenever you feel comfortable.</p>"
    };

    var exp_break = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p><strong>Perfect!</strong></p>
        <p>Maybe it's time for a short break! </br>Take your time, and press any key whenever you feel ready to get back to our experiment.</p>
      `,
      post_trial_gap: 500
    };

    /* instruction for learning phase_1 */
    // Passive learning
    var instruction_1 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> In this section, <br />
        You will <strong>compare pairs of images </strong> which appear in the center of the screen.<br />
        Below each image will be <strong> a statement that describes it</strong>. <br/>
        <p> (Press any key to begin) </p>
      `,
      post_trial_gap: 500
    };

    // Active learning
    var instruction_2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> In this section, <br />
        you will continue to <strong>compare pairs of images</strong>. <br/>
        However, you will now be asked to <strong>choose the correct description</strong> for the <strong>image on the right</strong>.</p>
        (Press any key to continue)
      `,
      /* I am deliberately not telling them that they will be given limitless chances until they get it right -- just so they can pay more attention.*/
      post_trial_gap: 500
    };

    /* instruction for testing phase_1 */
    var instruction_3 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong> </p>
        <p> Continue answering our questions by <strong>selecting the correct description</strong> for the <strong>image on the right</strong>.</br> However, we are no longer telling you whether you\'ve got the right answer or not!</p>
        <p> (Press any key to continue)</p>
      `,
      post_trial_gap: 500
    };

    /* instruction for learning phase_2 */
    //Passive
    var instruction_4 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> Welcome back!</p>
        <p> You will continue to see pairs of images accompanied by the description.
        <br/> This time, we are giving you more detailed description, using <strong>our own mysterious scale</strong>... </p>
        <p>(Press any key to continue)</p>
      `,
      post_trial_gap: 500
    };

    //Active
    var instruction_5 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Awesome!</strong> <br/>
        Now, we would like to ask you to choose the <strong>correct statement for the image on the right</strong>.</p>
        Press any key to continue.
      `,
      post_trial_gap: 500
    };

    /* instruction for testing phase_2a */
    var instruction_6 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great Job!</strong> </p>
        <p> We're going to give you another set of questions. </br> Find the identical image!</p>
        <p> Press any key to continue.</p>
      `,
      post_trial_gap: 500
    };

    /* instruction for testing phase_2b */
    var instruction_7 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Excellent!</strong> </p>
        <p> We're going to give you one last set of questions.<br/> You will continue to <strong>compare pairs of images</strong> and <strong>choose the correct description</strong> for the <strong>image on the right</strong>!</p>
        <p> Press any key to continue.</p>
      `,
      post_trial_gap: 500
    };

    /* instruction for testing phase_2b */
    var instruction_8 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p> <strong>Great job!</strong> </p>
        <p> This is the last part of the experiment.<br/> This time you will be seeing <strong>different descriptions with familiar concepts </strong>. Choose the best one!</p>
        <p> Press any key to continue.</p>
      `,
      post_trial_gap: 500
    };

      /* instruction for testing phase_2b */
    var instruction_xab = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p>Awesome!</p>
        <p>Now we are giving you a task similar to what you did at the beginning of the experiment. </br>Your task is to find <strong>the same image</strong> shown at the top of the screen.</p>
        <p>Press any key to continue.</p>
      `,
      post_trial_gap: 500
    };


     /* Fixation */
    var fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div style="font-size:60px;">+</div>`,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: {
        task: `fixation`
      }
    };
    var instruction_break = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <p style="font-size:20px;font-weight:bold;"> Look at this pair! </p>
        <p> (Press any key when you are ready)</p>
      `,
    };


    // frimble vs. orpital
    var choices = ['frimble', 'orpital']
    
    // word assignment
    if (Math.random() < 0.5) {
        var A = choices[0];
        var B = choices[1];
    } else {
        var A = choices[1];
        var B = choices[0];
    }
      
    
    /*
    var test_stimuli_s = [
      { stimulus: 'img/tall1.png', word: "tall", antonym: "short"},
      { stimulus: 'img/tall2.png', word: "tall", antonym: "short"},
      { stimulus: 'img/tall3.png', word: "tall", antonym: "short"},
      { stimulus: 'img/dark1.png', word: "dark", antonym: "light"},
      { stimulus: 'img/dark2.png', word: "dark", antonym: "light"},
      { stimulus: 'img/dark3.png', word: "dark", antonym: "light"},
      ];
     */

    // /* Function for generating canvas stimuli */
    // function Morphfunction(canvas, p1, p2){
    //     const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
    //     canvasMorpher.combineImages(canvas, p1, p2);
    // }


    /* Function for generating canvas stimuli */
    function Morphfunction(canvas, p1, p2, n1=0, n2=0) {
      return new Promise((resolve) => {
        const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
        canvasMorpher.combineImages(canvas, p1, p2, n1, n2, () => {
          resolve();
        });
      });
    }

    /* Function for generating canvas stimuli */
    function XAB_test(canvas, p1, p2, n1=0, n2=0, condition) {
      return new Promise((resolve) => {
        const canvasMorpher = new CanvasMorpher(canvas, 80, 138);
        console.log('noise', p1, p2, n1, n2, condition);
        canvasMorpher.XAB(canvas, p1, p2, n1, n2, condition, () => {
          resolve();
        });
      });
    }
   

   // random generator
   function getRandomArbitrary(min, max) {
        return Math.random() * (max - min) + min;
      }
      
    // Initialize the random generator with a fixed seen
    Math.seedrandom('fixed-seed');
    
    /* Function for Learn stimuli (less restriction)*/
    function generateLearnStimuli(numStimuli, promptType = 1) { // 1=passive, 2=active
      const stimuli = [];
      const differences = [];
      for (let i = 3; i <= 19; i++) {
        differences.push(0.05 * i);
      }

      for (let i = 0; i < numStimuli; i++) {
        let p1, p2;
        const diff = differences[Math.floor(Math.random() * differences.length)];

        if (i < numStimuli / 2) {
          p1 = getRandomArbitrary(0.05, 1 - diff);
          p2 = p1 + diff;
        } else {
          p2 = getRandomArbitrary(0.05, 1 - diff);
          p1 = p2 + diff;
        }

        const n1 = getRandomArbitrary(-1, 1);
        const n2 = getRandomArbitrary(-1, 1);

        let prompt;
        if (promptType === 1) {
            if (p1 > p2){
                prompt = `<p style="font-size:20px;"> Compared to the left one, <strong>the right one is more ${A}</strong>.</p> <br /> (Press any key to continue to the next image)`;

            } else{
                prompt = `<p style="font-size:20px;"> Compared to the left one, <strong>the right one is more ${B}</strong>.</p> <br /> (Press any key to continue to the next image)`;
            }
        } else {
          prompt = `<p>The right image is...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`;
        }

        stimuli.push({
          stimulus: (i + 1).toString(),
          task: 'block1_passive_response',
          radius_a: p1,
          radius_b: p2,
          n1: n1,
          n2: n2,
          prompt: prompt,
          correct_response: p1 > p2 ? 'q' : 'p'});
      }

      return stimuli;
    }

      
      /*test stimuli; more restricted */
      function generateTestStimuli(numStimuli) {
        const stimuli = [];
        const differences = [0.05 * 3, 0.05 * 6, 0.05 * 10, 0.05 * 14]; //0.05 * d where d = |p1-p2|

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.15, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.15, 1 - diff);
            p1 = p2 + diff;
          }

          const n1 = getRandomArbitrary(-1, 1);
          const n2 = getRandomArbitrary(-1, 1);

          stimuli.push({
            stimulus: (i + 1).toString(),
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            correct_response: p1 > p2 ? 'q' : 'p'
          });
        }

        return stimuli;
      }

      function passiveDegreeStimuli(numStimuli, n) {
        const stimuli = [];
        const differences = [];
        for (let i = 3; i <= 14; i++) {
          differences.push(0.05 * i);
        }

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.05, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.05, 1 - diff);
            p1 = p2 + diff;
          }

          const n1 = getRandomArbitrary(-1, 1);
          const n2 = getRandomArbitrary(-1, 1);

          const degreeDifference = Math.trunc(Math.abs(p1 - p2) / n);
          let prompt;
          if (p1 > p2) {
              prompt = `<p style="font-size:20px;">Compared to the left one, <strong>the right one is ${degreeDifference} degree(s) more ${A}</strong>.</p><br />(Press any key to continue to the next image)`;
          } else {
              prompt = `<p style="font-size:20px;">Compared to the left one, <strong>the right one is ${degreeDifference} degree(s) more ${B}</strong>.</p><br />(Press any key to continue to the next image)`;
          }

          stimuli.push({
            stimulus: (i + 1).toString(),
            task: 'block2_passive_response',
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            prompt: prompt,
            correct_response: p1 > p2 ? 'q' : 'p'
          });
        }

        return stimuli;
      }

      function activeDegreeStimuli(numStimuli, n) {
        const stimuli = [];
        const differences = [];
        for (let i = 3; i <= 14; i++) {
          differences.push(0.05 * i);
        }

        for (let i = 0; i < numStimuli; i++) {
          let p1, p2;
          const diff = differences[Math.floor(Math.random() * differences.length)];

          if (i < numStimuli / 2) {
            p1 = getRandomArbitrary(0.05, 1 - diff);
            p2 = p1 + diff;
          } else {
            p2 = getRandomArbitrary(0.05, 1 - diff);
            p1 = p2 + diff;
          }

          const n1 = getRandomArbitrary(-1, 1);
          const n2 = getRandomArbitrary(-1, 1);

          const degreeDifference = Math.trunc(Math.abs(p1 - p2) / n);
          let prompt;
          if (p1 > p2) {
              prompt = `<p style="font-size:20px;"><strong>From 0 to 4</strong>, how many degree(s) is <strong>the right one more ${A}</strong>?</br>(Use number keys)</p>`;
          } else {
              prompt = `<p style="font-size:20px;"><strong>From 0 to 4</strong>, how many degree(s) is <strong>the right one more ${B}</strong>?</br>(Use number keys)</p>`;
          }

          stimuli.push({
            stimulus: (i + 1).toString(),
            radius_a: p1,
            radius_b: p2,
            n1: n1,
            n2: n2,
            prompt: prompt,
            correct_response: degreeDifference
          });
        }

        return stimuli;
      }
      /* Specific stimuli for pre_test_xab */
      // condition == 1 then p1 is shown as main stimulus, else p2
      var pre_test_stimuli = [
        { p1: 0.05, p2: 0.2, n1: 0, n2: 0,  condition: 1},
        { p1: 0.25, p2: 0.4, n1: 0, n2: 0 },
        { p1: 0.45, p2: 0.6, n1: 0, n2: 0,  condition: 1},
        { p1: 0.65, p2: 0.8, n1: 0, n2: 0 },
        { p1: 0.85, p2: 1, n1: 0, n2: 0,  condition: 1},
        { p1: 0.05, p2: 0.05, n1: 0, n2: 0.15*670/70 }, //n2 is like 9....
        { p1: 0.25, p2: 0.25, n1: 0, n2: 0.15*670/70,  condition: 1},
        { p1: 0.45, p2: 0.45, n1: 0, n2: 0.15*670/70 },
        { p1: 0.65, p2: 0.65, n1: 0, n2: 0.15*670/70,  condition: 1},
        { p1: 0.85, p2: 0.85, n1: 0, n2: 0.15*670/70 }
      ];
      
      
      /* Function to convert specific stimuli to timeline variables */
      function convertToTimelineVariables(stimuli) {
        return stimuli.map((stimulus, index) => ({
          stimulus: index.toString(),
          radius_a: stimulus.p1,
          radius_b: stimulus.p2,
          n1: stimulus.n1,
          n2: stimulus.n2,
          condition: stimulus.condition,
          correct_response: stimulus.condition == 1 ? 'q' : 'p',
        }));
      }

      
      /*pretest*/
      var pre_test_xab_stimuli = convertToTimelineVariables(pre_test_stimuli);
      
      /* Stimuli for learning_phase_1 */
      var learn_stimuli_a1 = generateLearnStimuli(25, 1); // (25 trial, 1: passive)

      /* Stimuli for learning_phase_2 */
      var learn_stimuli_a2 = generateLearnStimuli(25, 2); // (25 trial, 2: active)

      /* Stimuli for learning_phase_1C */
      var learn_stimuli_c1h = passiveDegreeStimuli(25,0.15); // 25 passive learning, high precision (0.15)
      var learn_stimuli_c2h = activeDegreeStimuli(25,0.15); // 25 active larning, high precision 

      var learn_stimuli_c1l = passiveDegreeStimuli(25,0.3); // 25 passive learning, low precision (0.3)
      var learn_stimuli_c2l = activeDegreeStimuli(25,0.3); // 25 passive learning, low precision (0.3)

      /* Stimuli for testing_phase_1 */
    //after XAB test (identical to the pre_XAB_test)
      var test_stimuli_1 = generateTestStimuli(28); // 28 random parameters

      /* Stimuli for testing_phase_2: 38 total */
      //after XAB test (identical to the pre_XAB_test)
      //var test_stimuli_2 = generateTestStimuli(10); // 10 random parameters
      
      var test_stimuli_3 = generateTestStimuli(28) // 28 random parameters

/* Experiment procedures */

      var pre_test = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_pre_test`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 condition: (jsPsych.timelineVariable('condition')),
             },
        on_finish: function(data){
                   // Score the response as correct or incorrect.
                   if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                     data.wrong = false;
                   } else {
                     data.wrong = true;
                   }
         }
       };
      
      var XABtest = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_test`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 condition: (jsPsych.timelineVariable('condition')),
             },
        on_finish: function(data){
                   // Score the response as correct or incorrect.
                   if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                     data.wrong = false;
                   } else {
                     data.wrong = true;
                   }
         }
       };
      
      var XABtest2 = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [600, 600],
         stimulus: async function(c) {
           const stim = jsPsych.timelineVariable();
           await XAB_test(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'), jsPsych.timelineVariable('n1'), jsPsych.timelineVariable('n2'), jsPsych.timelineVariable('condition'));
           return c;
         },
         choices: ['q', 'p'],
         prompt: "<p>Which image is the same as the one on top? </br> Press '<strong>Q</strong>' for left; '<strong>P</strong>' for right.</p>",
         response_ends_trial: true,
         data: {
                 task: `XAB_test2`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
                 condition: (jsPsych.timelineVariable('condition')),
             },
        on_finish: function(data){
                   // Score the response as correct or incorrect.
                   if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                     data.wrong = false;
                   } else {
                     data.wrong = true;
                   }
         }
       };
      
    /* block1: learning task */
    /* 1.1 learning: define learning trials*/
    var learn_A_passive = {
        type: jsPsychCanvasKeyboardResponse,
        canvas_size: [400, 900],
        stimulus: async function(c) {
          await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'));
          return c;
        },
        prompt: jsPsych.timelineVariable(`prompt`),
        data: {
                task:jsPsych.timelineVariable('block1_passive_response'),
                stimuli_1: jsPsych.timelineVariable(`radius_a`),
                stimuli_2: jsPsych.timelineVariable(`radius_b`)
            },
      };

     var learn_A_active = {
        type: jsPsychCanvasKeyboardResponse,
        canvas_size: [400, 900],
        stimulus: async function(c) {
          await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'));
          return c;
        },
        response_ends_trial: true,
        data: {
                task: `block1_active_response`,
                stimuli_1: jsPsych.timelineVariable(`radius_a`),
                stimuli_2: jsPsych.timelineVariable(`radius_b`),
                correct_response: jsPsych.timelineVariable(`correct_response`)
            },
        choices: ['q', 'p'],
        prompt: jsPsych.timelineVariable(`prompt`),
        on_finish: function(data){
                         // Score the response as correct or incorrect.
                         if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                           data.wrong = false;
                         } else {
                           data.wrong = true;
                         }
        }
      };

      var looped_A_active = {
        timeline: [learn_A_active],
        loop_function: function(data){
          if (jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
            alert(`Nope, let\'s try again!`);
            return true;
            //jsPsych.resumeExperiment(learn_A_2b); // Resume the experiment
          } else{
            alert(`Yes! Great job!`);
            return false;
          }
        }
      };

      var test = {
         type: jsPsychCanvasKeyboardResponse,
         canvas_size: [400, 900],
         stimulus: async function(c) {
           await Morphfunction(c, jsPsych.timelineVariable(`radius_a`), jsPsych.timelineVariable(`radius_b`));
           return c;
         },
         response_ends_trial: true,
         data: {
                 task: `test_response`,
                 correct_response: jsPsych.timelineVariable(`correct_response`),
                 stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                 stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
             },

        choices: ['q', 'p'],
        prompt: `<p>The right image is...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`,
        on_finish: function(data){
                     // Score the response as correct or incorrect.
                     if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                       data.wrong = false;
                     } else {
                       data.wrong = true;
                     }
         }
       };

       var learn_C_active = {
          type: jsPsychCanvasKeyboardResponse,
          canvas_size: [400, 900],
          stimulus: async function(c) {
            await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'));
            return c;
          },
          prompt: jsPsych.timelineVariable(`prompt`),
          response_ends_trial: true,
          data: {
                  task: `block2_active_response`,
                  correct_response: jsPsych.timelineVariable(`correct_response`),
                  stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                  stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
              },
          on_finish: function(data){
                  // Score the response as correct or incorrect.
                  if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                    data.wrong = false;
                  } else {
                    data.wrong = true;
                  }
                }
        };

        var looped_C_active = {
          timeline: [learn_C_active],
          loop_function: function(data){
            if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
              alert(`Nope, let\'s try again!`);
              return true;
              //jsPsych.resumeExperiment(learn_A_2b); // Resume the experiment
            } else{
              alert(`Yes! Great job!`);
              return false;
            }
          }
        };

        var test_equally = {
           type: jsPsychCanvasKeyboardResponse,
           canvas_size: [400, 900],
           stimulus: async function(c) {
             await Morphfunction(c, jsPsych.timelineVariable('radius_a'), jsPsych.timelineVariable('radius_b'));
             return c;
           },
           response_ends_trial: true,
           data: {
                   task: `test_response`,
                   correct_response: jsPsych.timelineVariable(`correct_response`),
                   stimuli_1: (jsPsych.timelineVariable(`radius_a`)),
                   stimuli_2: (jsPsych.timelineVariable(`radius_b`)),
               },


          choices: ['q', 'p'],
          prompt: `<p>The right image is...</br> <strong>Q</strong>: more <strong>${A}</strong>.&emsp;&emsp; <strong>P</strong>: more <strong>${B}</strong>.</p>`,
          on_finish: function(data){
                       // Score the response as correct or incorrect.
                       if(jsPsych.data.get().last(1).values()[0].response != jsPsych.data.get().last(1).values()[0].correct_response){
                         data.wrong = false;
                       } else {
                         data.wrong = true;
                       }
           }
         };

      /*
         var real_adj = {
             type: jsPsychImageButtonResponse,
             stimulus: jsPsych.timelineVariable(`stimulus`),
             stimulus_height: 400,
             choices: function() {
               var word = jsPsych.timelineVariable('word');
               var antonym = jsPsych.timelineVariable('antonym');
               return [
                  `The right one is ${word}er.`,
                  `The right one is ${antonym}.`,
                  `They are equally ${word}.`,
                  `They are equally ${antonym}.`
                ];
            },
         };

*/
      // Reset the RNG to use the default random behavior for timeline randomization
      Math.seedrandom();

      /* define learning procedure*/
      var pre_test_xab = {
        timeline: [instruction_break, pre_test],
        timeline_variables:pre_test_xab_stimuli,
        randomize_order: true
      };
      // Block I: learning (passive + active)
      var learn_procedure_1 = {
        timeline: [instruction_break, learn_A_passive],
        timeline_variables:learn_stimuli_a1,
        randomize_order: true
      };
      var learn_procedure_2 = {
        timeline: [instruction_break,looped_A_active],
        timeline_variables: learn_stimuli_a2,
        randomize_order: true,
      };
      // Block II: testing
    
      var xab_test_1 = {
        timeline: [instruction_break, XABtest],
        timeline_variables:pre_test_xab_stimuli,
        randomize_order: true
      };
      var test_procedure_1 = {
         timeline: [instruction_break, test],
         timeline_variables: test_stimuli_1,
         randomize_order: true,
       };
       // Block III: learning (passive + active)
       var learn_procedure_3h = {
         timeline: [instruction_break, learn_A_passive],
         timeline_variables:learn_stimuli_c1h,
         randomize_order: true,
       };

       var learn_procedure_4h = {
         timeline: [instruction_break,looped_C_active],
         timeline_variables: learn_stimuli_c2h,
         randomize_order: true,
       };
      
      var learn_procedure_3l = {
        timeline: [instruction_break, learn_A_passive],
        timeline_variables:learn_stimuli_c1l,
        randomize_order: true,
      };

      var learn_procedure_4l = {
        timeline: [instruction_break,looped_C_active],
        timeline_variables: learn_stimuli_c2l,
        randomize_order: true,
      };
       // Block IV: testing
       var xab_test_2 = { // XAB TEST
          timeline: [instruction_break, XABtest2],
          timeline_variables: pre_test_xab_stimuli,
          randomize_order: true,
        };

      var test_procedure_3 = {
           timeline: [instruction_break, test_equally],
           timeline_variables: test_stimuli_3,
           randomize_order: true,
         };

     /*
     var survey = {
       timeline: [instruction_break, real_adj],
       timeline_variables: test_stimuli_s,
       randomize_order: true,
     }
      */

    
    // save to OFS server (check documentation)
    //  var save_server_data = {
    //   type: jsPsychCallFunction,
    //   func: function () {
    //     var data = jsPsych.data.get().ignore("internal_node_id").json();//ommitting .filter({task: 'property'}) to include all trials
    //     var xhr = new XMLHttpRequest();
    //     xhr.open('POST', 'php/save_json.php');
    //     xhr.setRequestHeader('Content-Type', 'application/json');
    //     xhr.send(JSON.stringify({ filedata: data }));
    //     jsPsychPipe.save(experiment_id, filename, data)
    //   },
    //   post_trial_gap: 1000
    // }

    const expID = "iPtLEVGIdxPA";
    let condition;
    let group_name;

    const save_server_data = {
      type: jsPsychPipe,
      action: "save",
      experiment_id: expID,
      filename: () => `${group_name}_${subjectID}_${A}.csv`,
      data_string: ()=>jsPsych.data.get().csv(),
      post_trial_gap: 1000
    };

    async function getCondition() {
      try {
        const response = await jsPsychPipe.getCondition(expID);
        console.log('Response:', response); // Log the response to confirm

        // Check if the response is a valid condition number
        if (typeof response === 'number') {
          return response;
        } else {
          throw new Error('Invalid response format');
        }
      } catch (error) {
        console.error('Failed to get condition:', error);
      }
    }


    async function createExperiment() {
      condition = await getCondition();

      var timeline = [];

      timeline.push(welcome, consentTrial);

      /*block1: XAB & Pretrain; Same across all groups*/
      timeline.push(pre_test_xab);
      timeline.push(instruction_1);
      timeline.push(learn_procedure_1);
      timeline.push(instruction_2);
      timeline.push(learn_procedure_2);

      /*block2: test; Same across all groups*/
      timeline.push(instruction_xab);
      timeline.push(xab_test_1);
      timeline.push(instruction_3);
      timeline.push(test_procedure_1);
      timeline.push(exp_break);

      /*block3: train; Constrast between two groups*/
      
      //const group = Math.random() < 0.5 ? 0 : 1; // 0 for high precision, 1 for low precision
      
      if (condition === 0) { //high precision
        group_name = 'high';
        jsPsych.data.addProperties({ precision_group: 'high' });
        timeline.push(instruction_4);
        timeline.push(learn_procedure_3h);
        timeline.push(instruction_5);
        timeline.push(learn_procedure_4h);
      } else { // low precision
        group_name = 'low';
        jsPsych.data.addProperties({ precision_group: 'low' });
        timeline.push(instruction_4);
        timeline.push(learn_procedure_3l);
        timeline.push(instruction_5);
        timeline.push(learn_procedure_4l);
      }

      /*block4: test; Same across all groups*/
      timeline.push(instruction_6);
      timeline.push(xab_test_2);
      timeline.push(instruction_7);
      timeline.push(test_procedure_3);

      /*survey: Same across all groups*/
      //Follow-up trial with real adjectives
      //timeline.push(instruction_8);
      //timeline.push(survey);


      /*save_data*/
      timeline.push(waiting);
      timeline.push(save_server_data);
      timeline.push(closing);
      
      
      jsPsych.run(timeline)
    }

  createExperiment();


  </script>
</html>

